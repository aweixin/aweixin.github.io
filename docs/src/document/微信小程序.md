# 微信小程序

## 解决微信小程序首页多个弹窗混合问题

> 一个小程序开发，有多个弹窗，多个弹窗之间会互相覆盖，导致用户无法操作弹窗，如何解决？


文件`popupConfig.ts`用于管理所有弹窗的配置文件

```ts
/**
 * 弹窗类型
 */
export type PopupType = 'login' | 'phoneAuth' | 'welcomeCoupon' | 'activity' | 'marketing'

export interface PopupItem {
    type: PopupType
    priority: number // 优先级，越小越高
    condition: () => Promise<boolean> // 是否满足展示条件（可异步）
    show: () => Promise<void> // 展示弹窗并返回用户操作结果
    key: string // 用于 localStorage 记录状态，如 'popup_login'
}

async function checkHasUserInfo() {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(false)
        }, 500)
    })
}

/**
 * 登录弹窗
 */
export const loginPopup: PopupItem = {
    type: 'login',
    priority: 1,
    key: 'popup_login_done',
    async condition() {
        const hasUserInfo = await checkHasUserInfo()
        return !hasUserInfo
    },
    async show() {
        return new Promise<void>((resolve, reject) => {
            uni.showModal({
                title: '请登录',
                content: '请登录后查看',
                success(res) {
                    if (res.confirm) {
                        resolve() // 用户点击确定，表示登录成功
                    } else {
                        reject(new Error('用户取消登录')) // 用户点击取消，抛出错误
                    }
                },
                fail(err) {
                    reject(new Error(`弹窗显示失败: ${err.errMsg}`)) // 弹窗显示失败，抛出错误
                },
            })
        })
    },
}

/**
 * 新人优惠券弹窗
 */
export const welcomeCouponPopup: PopupItem = {
    type: 'welcomeCoupon',
    priority: 2,
    key: 'popup_welcome_coupon_done',
    async condition() {
        return new Promise<boolean>((resolve) => {
            setTimeout(() => {
                resolve(true)
            }, 1500)
        })
    },
    async show() {
        return new Promise<void>((resolve, reject) => {
            uni.showModal({
                title: '新人优惠券',
                content: '新人优惠券已发放，请查看',
                success(res) {
                    if (res.confirm) {
                        resolve() // 用户点击确定，表示已查看
                    } else {
                        reject(new Error('用户取消查看')) // 用户点击取消，抛出错误
                    }
                },
                fail(err) {
                    reject(new Error(`弹窗显示失败: ${err.errMsg}`))
                },
            })
        })
    },
}

```

`popupManager.ts` 用于管理所有弹窗的显示逻辑

```ts
/**
 * 弹窗调度器
 */

// popupManager.ts
import type {PopupItem} from './popupConfig'

class PopupManager {
    private queue: PopupItem[] = []

    async init(popupList: PopupItem[]) {
        // 1. 过滤掉已处理过的弹窗（根据 localStorage）
        const filtered = popupList.filter((item) => {
            const done = wx.getStorageSync(item.key)
            return !done
        })

        // 2. 按优先级排序（升序）
        this.queue = filtered.sort((a, b) => a.priority - b.priority)

        // 3. 依次尝试展示
        await this.processQueue()
    }

    private async processQueue() {
        while (this.queue.length > 0) {
            const current = this.queue.shift()!

            // 检查是否满足展示条件（可能因网络/状态变化而失效）
            const shouldShow = await current.condition()
            if (!shouldShow)
                continue

            // 展示弹窗（阻塞后续弹窗，直到用户操作完成）
            await current.show()

            // 标记为“已处理”（无论用户是否同意）
            wx.setStorageSync(current.key, true)
        }
    }
}

// 导出单例
export const popupManager = new PopupManager()
// 加上 await 会阻止后面的逻辑执行
// popupManager.init([
//     loginPopup,
//     welcomeCouponPopup,
// ])
```

## 小程序中 onLaunch 和 Page 加载机制存在异步

> 例如：我想在 app.js 中 ，请求接口保存多语言数据，但是因为 onLaunch 是异步的，所以保存的数据会丢失。

```ts
// app.js 顶部
let resolveLogin;
export const loginReady = new Promise(resolve => resolveLogin = resolve);

App({
    globalData: {whenLoginReady: loginReady},
    onLaunch() {
        this.doLanguage().finally(() => {
            resolveLogin({success: !!this.globalData.token, ...});
        });
    }
});
```

在 page 页面中实现

```ts
// page.js
const app = getApp();
const result = await app.globalData.whenLoginReady;
```

## 微信小程序音频播放器封装

```js
/**
 * 微信小程序音频播放器封装（基于 InnerAudioContext）
 * @author Mr.xu
 * @date 2025-06-01
 * @version 1.0.2
 * @description 封装了微信小程序音频播放器的常用方法，包括初始化、播放、暂停、继续、停止、设置音量、获取当前音量、跳转到指定时间、切换播放状态等。
 */
const AudioPlayer = {
        context: null,
        currentSrc: '',
        isPlaying: false,

        // 初始化音频上下文
        init() {
            if (!this.context) {
                this.context = wx.createInnerAudioContext();
                this._setupDefaultEvents();
            }
        },

        // 播放指定音频地址
        play(src) {
            if (!src) {
                console.warn('音频地址不能为空');
                return;
            }

            this.init();

            if (this.currentSrc === src && this.isPlaying) {
                console.log('该音频已在播放');
                return;
            }

            this.currentSrc = src;

            console.log('开始播放音频：', src)

            // 设置音频源并播放
            this.context.src = src;
            this.context.loop = true; // 开启循环播放
            this.context.play();
        },

        // 暂停播放
        pause() {
            if (this.context && this.isPlaying) {
                this.context.pause();
                this.isPlaying = false;
            }
        },

        // 继续播放
        resume() {
            if (this.context && !this.isPlaying && this.currentSrc) {
                this.context.play();
                this.isPlaying = true;
            }
        },

        // 停止播放
        stop() {
            if (this.context) {
                this.context.stop();
                this.isPlaying = false;
                this.currentSrc = '';
            }
        },

        // 设置音量（0 ~ 1）
        setVolume(volume) {
            if (this.context && volume >= 0 && volume <= 1) {
                this.context.volume = volume;
            }
        },

        // 获取当前音量
        getVolume() {
            return this.context?.volume ?? 1.0;
        },

        // 跳转到指定时间（单位：秒）
        seek(position) {
            if (this.context && position >= 0) {
                this.context.seek(position);
            }
        },
        toggleMusic() {
            if (this.isPlaying) {
                this.pause();
                return false;
            } else {
                this.resume();
                return true;
            }
        },

        // 监听基础事件
        _setupDefaultEvents() {
            const context = this.context;

            context.onPlay(() => {
                this.isPlaying = true;
                console.log('音频开始播放');
            });

            context.onPause(() => {
                this.isPlaying = false;
                console.log('音频暂停');
            });

            context.onStop(() => {
                this.isPlaying = false;
                this.currentSrc = '';
                console.log('音频停止');
            });

            context.onEnded(() => {
                this.isPlaying = false;
                this.currentSrc = '';
                console.log('音频播放结束');
            });

            context.onError((res) => {
                console.error('音频播放出错', res.errMsg, res.errCode);
            });

            context.onTimeUpdate(() => {
                // 可监听播放进度
            });
        },

        // 暴露 onError 方法供外部监听
        onError(callback) {
            if (this.context) {
                this.context.onError(callback);
            }
        }
    };

module.exports = AudioPlayer;
```

## new Date

> 微信小程序 new Date() 方法在iOS设备上无效的问题的解决方法

```javascript
let date = "2021-01-04 00:00"
let now = new Date(date.replace(/-/g, '/'))
```

## 小程序分包

> 小程序的限制

- 分包不能引用主包中的第三方库
- 正常情况下，小程序对代码包的限制是：大小不超过 2M，超过这个大小无法预览，也无法上传代码
- 做了分包加载的情况下，限制是：每个包大小不超过 2M，所有包总共的大小不超过 16M。

#### 分包后项目的构成

- 分包后，小程序项目由 1 个主包 + 多个分包组成：
- 主包：一般只包含项目的启动页面或 TabBar 页面、以及所有分包都需要用到的一些公共资源
- 分包：只包含和当前分包有关的页面和私有资源

#### 分包的加载规则

① 在小程序启动时，默认会下载主包并启动主包内页面 `tabBar` 页面需要放到主包中

② 当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示非 `tabBar` 页面可以按照功能的不同，划分为不同的分包之后，进行按需下载

```json
{
  "pages": [
    "pages/index/index",
    "pages/logs/logs"
  ],
  "subpackages": [
    {
      "root": "pages/packageA",
      "pages": [
        "child/child",
        "parent/parent"
      ]
    }
  ]
}
```

访问路径：packageA 访问子页面 child

```js
gotoChild()
{
    wx.navigateTo({
        url: '/pages/packageA/child/child',
    })
}
```

## 微信小程序 跳转

```js
export const goUrl = (url: string) => {
    // switchTab
    if (url.startsWith('https')) {
        // url 编码
        url = encodeURIComponent(url);
        wx.navigateTo({
            url: `/pages/webview/webview?url=${url}`,
            fail: (err) => {
                console.log(err, '跳转失败')
            }
        });
        return;
    }
    wx.switchTab({
        url: url,
        fail: (err) => {
            wx.navigateTo({
                url: url,
                fail: (err) => {
                    console.log(err, '跳转失败')
                }
            });
        }
    })
}


// url 解码
export const decodeUrl = (url: string) => {
    return decodeURIComponent(url);
}
```

## 微信小程序 Request 封装

```js
class Request {
    defaultConfig = {
        baseUrl: '',
        header: {},
    }

    interceptor = {
        request: (config: any) => {
            return config;
        },
        response: (res: any) => {
            return res;
        },
    }

    constructor(
        baseUrl: string,
        headers = {
            'Content-Type': 'application/json',
        }
    ) {
        this.defaultConfig.baseUrl = baseUrl;
        this.defaultConfig.header = headers;
    }

    request(url: string, data: any = {}, header: any = {}, method: string = 'GET') {
        return new Promise((resolve, reject) => {
            let config = {
                url: url,
                data: data,
                header: header,
                method: method,
                success: (res: any) => {
                    resolve(res);
                },
                fail: (err: any) => {
                    reject(err);
                },
            };
            config.url = this.defaultConfig.baseUrl + url;
            config.header = {
                ...this.defaultConfig.header,
                ...header,
            };
            config = this.interceptor.request(config);
            wx.request(config);
            this.interceptor.response(config);
            wx.onNetworkStatusChange((res: any) => {
                if (!res.isConnected) {
                    reject(new Error('网络已断开'));
                }
            });
        });
    }

    get(url: string, data: any = {}, header: any = {}) {
        return this.request(url, data, header, 'GET');
    }

    post(url: string, data: any = {}, header: any = {}) {
        return this.request(url, data, header, 'POST');
    }
}

export default Request;


const http = new Request('https://www.baidu.com');
http.interceptor.request((config) => {
    console.log('请求拦截器', config);
    return config;
})
http.interceptor.response((res) => {
    console.log('响应拦截器', res);
    return res
});

http.post('/api/user').then((res) => {
    console.log(res);
})
```

## 格式化接口返回的html内容

```js
export const formatHtml = (html: string) => {
    let result = html
    result = result.replace(/section/gi, "div")
    result = result.replace(/data-src/gi, "src")
    result = result.replace(/src="data:/gi, 'data-src="data:')
    result = result.replace(/<img[^>]*>/gi, function (match: any) {
        var match = match.replace(/style/gi, "styles")
        return match
    })
    result = result.replace(/\<img/gi, '<img style="max-width:100%!important;height:auto!important;display:block;" ')
    return result
}
```